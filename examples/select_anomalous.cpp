#include <iostream>
#include <map>
#include <array>

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TTree.h>
#include <TString.h>

#include <ROOT/RDataFrame.hxx>

bool chi2Selection(const double chi2Single, const double chi2Double)
{
  return chi2Single - chi2Double >= 25;
}

bool xmaxSelection(const double xmax1, const double xmax2)
{
  auto min = std::min(xmax1, xmax2);
  auto max = std::max(xmax1, xmax2);
  return max-min >= 300 && min > 0 && max < 2000;
}

bool ecalSelection(const double ecal1, const double ecal2)
{
  return std::min(ecal1, ecal2) >= 0.2 * (ecal1 + ecal2);
}

int
main(
  int argc,
  char** argv
)
{
  // let computations be performed in parallel
  // ROOT::EnableImplicitMT();

  // create a TChain to read all files generated by fit_conex_anomalous
  TChain chain("data");
  for (int ifile = 1; ifile < argc; ++ifile) {
    chain.Add(argv[ifile]);
  }

  // we parse the TChain through a dataframe
  ROOT::RDataFrame df(chain);

  // this selection is solely based on the number of inflection points.
  // because a Gaisser-Hillas function (or, equivalently, a USP function)
  // has only two inflection points, we tag profiles with more than two
  // inflection points as anomalous.
  auto inflectionPointsSelection = df.Filter("ninflec > 2");

  // this second selection applies the same cuts as in arXiv:1111.0504:
  // - a fit to a double gaisser hillas is well succeeded
  // - a double gaisser hillas improves the chi2 by at least 25
  // - distance between maxima is at least 300 g/cm^2
  // - both maximum are within the simulated profile range
  // - each subshower deposits at least 20% of the total calorimetric energy
  auto doubleGaisserHillasSelection = df
    .Filter([](const unsigned int status){return status == 0;}, {"ghDoubleFit.status"})
    .Filter(chi2Selection, {"ghSingleFit.chi2", "ghDoubleFit.chi2"})
    .Filter(xmaxSelection, {"ghDoubleFit.xmax_1", "ghDoubleFit.xmax_2"})
    .Filter(ecalSelection, {"ghDoubleFit.ecal_1", "ghDoubleFit.ecal_2"});

  // the third selection method is completely analogous to the above one,
  // with the difference that we are using fits to a USP function, instead
  // of the default Gaisser-Hillas
  auto doubleUSPSelection = df
    .Filter([](const unsigned int status){return status == 0;}, {"uspDoubleFit.status"})
    .Filter(chi2Selection, {"uspSingleFit.chi2", "uspDoubleFit.chi2"})
    .Filter(xmaxSelection, {"uspDoubleFit.xmax_1", "uspDoubleFit.xmax_2"})
    .Filter(ecalSelection, {"uspDoubleFit.ecal_1", "uspDoubleFit.ecal_2"});

  // write results to stdout
  std::map<TString, std::vector<unsigned int>> nameIndexMap;

  const std::vector<std::string> mapColumns = {"fileName", "ishower"};

  auto fillMap = [&](const TString& s, const unsigned int i) {
    nameIndexMap[s].push_back(i);
  };

  auto printMapAndClear = [&](const std::string& prefix = ""){
    for (auto& [fname, indices] : nameIndexMap) {
      std::cout << prefix << std::setw(45) << fname << "#" << indices.size() << ":";
      for (auto& index : indices) {
        std::cout << std::setw(5) << index;
      }
      std::cout << std::endl;
    }

    nameIndexMap.clear();
  };

  // selection based on the number of inflection points
  inflectionPointsSelection.Foreach(fillMap, mapColumns);
  printMapAndClear("ninflec:");

  // selection based on double GH fits
  doubleGaisserHillasSelection.Foreach(fillMap, mapColumns);
  printMapAndClear("doubleGH:");

  // selection based on double USP fits
  doubleUSPSelection.Foreach(fillMap, mapColumns);
  printMapAndClear("doubleUSP:");

  return 0;
}